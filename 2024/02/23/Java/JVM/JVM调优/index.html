

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="PALE13">
  <meta name="keywords" content="">
  
    <meta name="description" content="JVM参数总结堆内存相关Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。   显式指定堆内存–Xms和-Xmx 与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现 12-Xms&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM调优">
<meta property="og:url" content="http://example.com/2024/02/23/Java/JVM/JVM%E8%B0%83%E4%BC%98/index.html">
<meta property="og:site_name" content="PALE13">
<meta property="og:description" content="JVM参数总结堆内存相关Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。   显式指定堆内存–Xms和-Xmx 与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现 12-Xms&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240417214440689.png">
<meta property="og:image" content="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418003009546.png">
<meta property="og:image" content="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418160202135.png">
<meta property="og:image" content="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418180232127.png">
<meta property="og:image" content="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418180559019.png">
<meta property="article:published_time" content="2024-02-23T01:35:21.000Z">
<meta property="article:modified_time" content="2024-05-17T13:12:33.042Z">
<meta property="article:author" content="PALE13">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240417214440689.png">
  
  
  
  <title>JVM调优 - PALE13</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"fSj01qIZ1mNzIMoPkGGM4LIB-gzGzoHsz","app_key":"OVGCjDnyLgmimKVrlTnxrRC9","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  
    <!-- Google tag (gtag.js) -->
    <script async>
      if (!Fluid.ctx.dnt) {
        Fluid.utils.createScript("https://www.googletagmanager.com/gtag/js?id=", function() {
          window.dataLayer = window.dataLayer || [];
          function gtag() {
            dataLayer.push(arguments);
          }
          gtag('js', new Date());
          gtag('config', '');
        });
      }
    </script>
  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>PALE13</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="JVM调优"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-02-23 09:35" pubdate>
          2024年2月23日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          36 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">JVM调优</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="JVM参数总结"><a href="#JVM参数总结" class="headerlink" title="JVM参数总结"></a><strong>JVM参数总结</strong></h2><h3 id="堆内存相关"><a href="#堆内存相关" class="headerlink" title="堆内存相关"></a><strong>堆内存相关</strong></h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240417214440689.png" srcset="/img/loading.gif" lazyload alt="image-20240417214440689" style="zoom:50%;" />

<p><strong>显式指定堆内存–Xms和-Xmx</strong></p>
<p>与性能有关的最常见实践之一是根据应用程序要求初始化堆内存。如果我们需要指定最小和最大堆大小（推荐显示指定大小），以下参数可以帮助你实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms&lt;heap size&gt;[unit]<br>-Xmx&lt;heap size&gt;[unit]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>heap size</strong> 表示要初始化内存的具体大小。</li>
<li><strong>unit</strong> 表示要初始化内存的单位。单位为 <em><strong>“ g”*</strong> (GB)、</em>*<em>“ m”*<strong>（MB）、</strong></em>“ k”***（KB）。</li>
</ul>
<p>举个例子 ，如果我们要为 JVM 分配最小 2 GB 和最大 5 GB 的堆内存大小，我们的参数应该这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xms2G -Xmx5G<br></code></pre></td></tr></table></figure>



<p><strong>显式新生代内存(Young Generation)</strong></p>
<p>根据<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/sizing.html">Oracle 官方文档</a>，在堆总可用内存配置完成之后，第二大影响因素是为 <code>Young Generation</code> 在堆内存所占的比例。默认情况下，YG 的最小大小为 1310 <em>MB</em>，最大大小为 <em>无限制</em>。</p>
<p>一共有两种指定 新生代内存(Young Generation)大小的方法：</p>
<p><strong>1.通过<code>-XX:NewSize</code>和<code>-XX:MaxNewSize</code>指定</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:NewSize=&lt;young size&gt;[unit]<br>-XX:MaxNewSize=&lt;young size&gt;[unit]<br></code></pre></td></tr></table></figure>

<p>举个例子，如果我们要为 新生代分配 最小 256m 的内存，最大 1024m 的内存我们的参数应该这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:NewSize=256m<br>-XX:MaxNewSize=1024m<br></code></pre></td></tr></table></figure>



<p><strong>2.通过<code>-Xmn&lt;young size&gt;[unit]</code>指定</strong></p>
<p>如果我们要为 新生代分配 256m 的内存（NewSize 与 MaxNewSize 设为一致），我们的参数应该这样来写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">-Xmn256m<br></code></pre></td></tr></table></figure>

<p>GC 调优策略中很重要的一条经验总结是这样说的：</p>
<blockquote>
<p>将新对象预留在新生代，由于 Full GC 的成本远高于 Minor GC，因此尽可能将对象分配在新生代是明智的做法，实际项目中根据 GC 日志分析新生代空间大小分配是否合理，适当通过“-Xmn”命令调节新生代大小，最大限度降低新对象直接进入老年代的情况。</p>
</blockquote>
<p>另外，你还可以通过 <strong><code>-XX:NewRatio=&lt;int&gt;</code></strong> 来设置老年代与新生代内存的比值。</p>
<p>比如下面的参数就是设置老年代与新生代内存的比值为 1。也就是说老年代和新生代所占比值为 1：1，新生代占整个堆栈的 1&#x2F;2。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">-XX:NewRatio=1<br></code></pre></td></tr></table></figure>



<p><strong>显式指定永久代&#x2F;元空间的大小</strong></p>
<p><strong>从 Java 8 开始，如果我们没有指定 Metaspace（元空间） 的大小，随着更多类的创建，虚拟机会耗尽所有可用的系统内存（永久代并不会出现这种情况）。</strong></p>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:PermSize=N <span class="hljs-comment">#方法区 (永久代) 初始大小</span><br>-XX:MaxPermSize=N <span class="hljs-comment">#方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span><br></code></pre></td></tr></table></figure>

<p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p><strong>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。</strong></p>
<p>下面是一些常用参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:MetaspaceSize=N <span class="hljs-comment">#设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）</span><br>-XX:MaxMetaspaceSize=N <span class="hljs-comment">#设置 Metaspace 的最大大小</span><br></code></pre></td></tr></table></figure>

<p><strong>修正（参见：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1947">issue#1947open in new window</a>）</strong>：</p>
<p>1、Metapace 的初始容量并不是 <code>-XX:MetaspaceSize</code> 设置，无论 <code>-XX:MetaspaceSize</code> 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。</p>
<p>可以参考 Oracle 官方文档 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html">Other Considerationsopen in new window</a> 中提到的：</p>
<blockquote>
<p>Specify a higher value for the option MetaspaceSize to avoid early garbage collections induced for class metadata. The amount of class metadata allocated for an application is application-dependent and general guidelines do not exist for the selection of MetaspaceSize. The default size of MetaspaceSize is platform-dependent and ranges from 12 MB to about 20 MB.</p>
<p>MetaspaceSize 的默认大小取决于平台，范围从 12 MB 到大约 20 MB。</p>
</blockquote>
<p>另外，还可以看一下这个试验：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/jqfppqqd98DfAJHZhFbmxA">JVM 参数 MetaspaceSize 的误解open in new window</a>。</p>
<p>2、Metaspace 由于使用不断扩容到<code>-XX:MetaspaceSize</code>参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC。</p>
<p>也就是说，MetaspaceSize 表示 Metaspace 使用过程中触发 Full GC 的阈值，只对触发起作用。</p>
<p>垃圾搜集器内部是根据变量 <code>_capacity_until_GC</code>来判断 Metaspace 区域是否达到阈值的，初始化代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">MetaspaceGC::initialize</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// Set the high-water mark to MaxMetapaceSize during VM initialization since</span><br>  <span class="hljs-comment">// we can&#x27;t do a GC during initialization.</span><br>  _capacity_until_GC = MaxMetaspaceSize;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>相关阅读：<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/issues/1204">issue 更正：MaxMetaspaceSize 如果不指定大小的话，不会耗尽内存 #1204open in new window</a> 。</p>
<h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a><strong>垃圾回收器</strong></h3><p>为了提高应用程序的稳定性，选择正确的<a target="_blank" rel="noopener" href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">垃圾收集open in new window</a>算法至关重要。</p>
<p>JVM 具有四种类型的 GC 实现：</p>
<ul>
<li>串行垃圾收集器</li>
<li>并行垃圾收集器</li>
<li>CMS 垃圾收集器</li>
<li>G1 垃圾收集器</li>
</ul>
<p>可以使用以下参数声明这些实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+UseSerialGC<br>-XX:+UseParallelGC<br>-XX:+UseParNewGC<br>-XX:+UseG1GC<br></code></pre></td></tr></table></figure>

<p>有关<em>垃圾回收</em>实施的更多详细信息，请参见<a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.md">此处open in new window</a>。</p>
<h3 id="GC-日志记录"><a href="#GC-日志记录" class="headerlink" title="GC 日志记录"></a><strong>GC 日志记录</strong></h3><p>生产环境上，或者其他要测试 GC 问题的环境上，一定会配置上打印 GC 日志的参数，便于分析 GC 相关的问题。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 必选</span><br><span class="hljs-comment"># 打印基本 GC 信息</span><br>-XX:+PrintGCDetails<br>-XX:+PrintGCDateStamps<br><span class="hljs-comment"># 打印对象分布</span><br>-XX:+PrintTenuringDistribution<br><span class="hljs-comment"># 打印堆数据</span><br>-XX:+PrintHeapAtGC<br><span class="hljs-comment"># 打印Reference处理信息</span><br><span class="hljs-comment"># 强引用/弱引用/软引用/虚引用/finalize 相关的方法</span><br>-XX:+PrintReferenceGC<br><span class="hljs-comment"># 打印STW时间</span><br>-XX:+PrintGCApplicationStoppedTime<br><br><span class="hljs-comment"># 可选</span><br><span class="hljs-comment"># 打印safepoint信息，进入 STW 阶段之前，需要要找到一个合适的 safepoint</span><br>-XX:+PrintSafepointStatistics<br>-XX:PrintSafepointStatisticsCount=1<br><br><span class="hljs-comment"># GC日志输出的文件路径</span><br>-Xloggc:/path/to/gc-%t.log<br><span class="hljs-comment"># 开启日志文件分割</span><br>-XX:+UseGCLogFileRotation<br><span class="hljs-comment"># 最多分割几个文件，超过之后从头文件开始写</span><br>-XX:NumberOfGCLogFiles=14<br><span class="hljs-comment"># 每个文件上限大小，超过就触发分割</span><br>-XX:GCLogFileSize=50M<br></code></pre></td></tr></table></figure>



<h3 id="处理-OOM"><a href="#处理-OOM" class="headerlink" title="处理 OOM"></a><strong>处理 OOM</strong></h3><p>对于大型应用程序来说，面对内存不足错误是非常常见的，这反过来会导致应用程序崩溃。这是一个非常关键的场景，很难通过复制来解决这个问题。</p>
<p>这就是为什么 JVM 提供了一些参数，这些参数将堆内存转储到一个物理文件中，以后可以用来查找泄漏:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof<br>-XX:OnOutOfMemoryError=<span class="hljs-string">&quot;&lt; cmd args &gt;;&lt; cmd args &gt;&quot;</span><br>-XX:+UseGCOverheadLimit<br></code></pre></td></tr></table></figure>

<p>这里有几点需要注意:</p>
<ul>
<li><strong>HeapDumpOnOutOfMemoryError</strong> 指示 JVM 在遇到 <strong>OutOfMemoryError</strong> 错误时将 heap 转储到物理文件中。</li>
<li><strong>HeapDumpPath</strong> 表示要写入文件的路径; 可以给出任何文件名; 但是，如果 JVM 在名称中找到一个 <code>&lt;pid&gt;</code> 标记，则当前进程的进程 id 将附加到文件名中，并使用<code>.hprof</code>格式</li>
<li><strong>OnOutOfMemoryError</strong> 用于发出紧急命令，以便在内存不足的情况下执行; 应该在 <code>cmd args</code> 空间中使用适当的命令。例如，如果我们想在内存不足时重启服务器，我们可以设置参数: <code>-XX:OnOutOfMemoryError=&quot;shutdown -r&quot;</code> 。</li>
<li><strong>UseGCOverheadLimit</strong> 是一种策略，它限制在抛出 OutOfMemory 错误之前在 GC 中花费的 VM 时间的比例</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h3><ul>
<li><code>-server</code> : 启用“ Server Hotspot VM”; 此参数默认用于 64 位 JVM</li>
<li><code>-XX:+UseStringDeduplication</code> : <em>Java 8u20</em> 引入了这个 JVM 参数，通过创建太多相同 String 的实例来减少不必要的内存使用; 这通过将重复 String 值减少为单个全局 <code>char []</code> 数组来优化堆内存。</li>
<li><code>-XX:+UseLWPSynchronization</code>: 设置基于 LWP (轻量级进程)的同步策略，而不是基于线程的同步。</li>
<li><code>-XX:LargePageSizeInBytes</code>: 设置用于 Java 堆的较大页面大小; 它采用 GB&#x2F;MB&#x2F;KB 的参数; 页面大小越大，我们可以更好地利用虚拟内存硬件资源; 然而，这可能会导致 PermGen 的空间大小更大，这反过来又会迫使 Java 堆空间的大小减小。</li>
<li><code>-XX:MaxHeapFreeRatio</code> : 设置 GC 后, 堆空闲的最大百分比，以避免收缩。</li>
<li><code>-XX:SurvivorRatio</code> : eden&#x2F;survivor 空间的比例, 例如<code>-XX:SurvivorRatio=6</code> 设置每个 survivor 和 eden 之间的比例为 1:6。</li>
<li><code>-XX:+UseLargePages</code> : 如果系统支持，则使用大页面内存; 请注意，如果使用这个 JVM 参数，OpenJDK 7 可能会崩溃。</li>
<li><code>-XX:+UseStringCache</code> : 启用 String 池中可用的常用分配字符串的缓存。</li>
<li><code>-XX:+UseCompressedStrings</code> : 对 String 对象使用 <code>byte []</code> 类型，该类型可以用纯 ASCII 格式表示。</li>
<li><code>-XX:+OptimizeStringConcat</code> : 它尽可能优化字符串串联操作。</li>
</ul>
<h2 id="JDK监控和故障处理工具"><a href="#JDK监控和故障处理工具" class="headerlink" title="JDK监控和故障处理工具"></a><strong>JDK监控和故障处理工具</strong></h2><h3 id="JDK-命令行工具"><a href="#JDK-命令行工具" class="headerlink" title="JDK 命令行工具"></a><strong>JDK 命令行工具</strong></h3><p>这些命令在 JDK 安装目录下的 bin 目录下：</p>
<ul>
<li><strong><code>jps</code></strong> (JVM Process Status）: 类似 UNIX 的 <code>ps</code> 命令。用于查看所有 Java 进程的启动类、传入参数和 Java 虚拟机参数等信息；</li>
<li>**<code>jstat</code>**（JVM Statistics Monitoring Tool）: 用于收集 HotSpot 虚拟机各方面的运行数据;</li>
<li><strong><code>jinfo</code></strong> (Configuration Info for Java) : Configuration Info for Java,显示虚拟机配置信息;</li>
<li><strong><code>jmap</code></strong> (Memory Map for Java) : 生成堆转储快照;</li>
<li><strong><code>jhat</code></strong> (JVM Heap Dump Browser) : 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果;</li>
<li><strong><code>jstack</code></strong> (Stack Trace for Java) : 生成虚拟机当前时刻的线程快照，线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合。</li>
</ul>
<h4 id="jps-查看所有-Java-进程"><a href="#jps-查看所有-Java-进程" class="headerlink" title="jps:查看所有 Java 进程"></a><strong>jps:查看所有 Java 进程</strong></h4><p><code>jps</code>(JVM Process Status) 命令类似 UNIX 的 <code>ps</code> 命令。</p>
<p><code>jps</code>：显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（Local Virtual Machine Identifier,LVMID）。<code>jps -q</code>：只输出进程的本地虚拟机唯一 ID。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jps<br><span class="hljs-number">7360</span> NettyClient2<br><span class="hljs-number">17396</span><br><span class="hljs-number">7972</span> Launcher<br><span class="hljs-number">16504</span> Jps<br><span class="hljs-number">17340</span> NettyServer<br></code></pre></td></tr></table></figure>

<p><code>jps -l</code>:输出主类的全名，如果进程执行的是 Jar 包，输出 Jar 路径。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jps <span class="hljs-literal">-l</span><br><span class="hljs-number">7360</span> firstNettyDemo.NettyClient2<br><span class="hljs-number">17396</span><br><span class="hljs-number">7972</span> org.jetbrains.jps.cmdline.Launcher<br><span class="hljs-number">16492</span> sun.tools.jps.Jps<br><span class="hljs-number">17340</span> firstNettyDemo.NettyServer<br></code></pre></td></tr></table></figure>

<p><code>jps -v</code>：输出虚拟机进程启动时 JVM 参数。</p>
<p><code>jps -m</code>：输出传递给 Java 进程 main() 函数的参数。</p>
<h4 id="jstat-监视虚拟机各种运行状态信息"><a href="#jstat-监视虚拟机各种运行状态信息" class="headerlink" title="jstat: 监视虚拟机各种运行状态信息"></a><strong>jstat: 监视虚拟机各种运行状态信息</strong></h4><p>jstat（JVM Statistics Monitoring Tool） 使用于监视虚拟机各种运行状态信息的命令行工具。 它可以显示本地或者远程（需要远程主机提供 RMI 支持）虚拟机进程中的类信息、内存、垃圾收集、JIT 编译等运行数据，在没有 GUI，只提供了纯文本控制台环境的服务器上，它将是运行期间定位虚拟机性能问题的首选工具。</p>
<p><strong><code>jstat</code> 命令使用格式：</strong></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">jstat -&lt;option&gt; [-<span class="hljs-type">t</span>] [-<span class="hljs-type">h</span>&lt;<span class="hljs-type">lines</span>&gt;] &lt;vmid&gt; [&lt;<span class="hljs-built_in">int</span><span class="hljs-type">erval</span>&gt; [&lt;<span class="hljs-type">count</span>&gt;]]<br></code></pre></td></tr></table></figure>

<p>比如 <code>jstat -gc -h3 31736 1000 10</code>表示分析进程 id 为 31736 的 gc 情况，每隔 1000ms 打印一次记录，打印 10 次停止，每 3 行后打印指标头部。</p>
<p><strong>常见的 option 如下：</strong></p>
<ul>
<li><code>jstat -class vmid</code>：显示 ClassLoader 的相关信息；</li>
<li><code>jstat -compiler vmid</code>：显示 JIT 编译的相关信息；</li>
<li><code>jstat -gc vmid</code>：显示与 GC 相关的堆信息；</li>
<li><code>jstat -gccapacity vmid</code>：显示各个代的容量及使用情况；</li>
<li><code>jstat -gcnew vmid</code>：显示新生代信息；</li>
<li><code>jstat -gcnewcapcacity vmid</code>：显示新生代大小与使用情况；</li>
<li><code>jstat -gcold vmid</code>：显示老年代和永久代的行为统计，从 jdk1.8 开始,该选项仅表示老年代，因为永久代被移除了；</li>
<li><code>jstat -gcoldcapacity vmid</code>：显示老年代的大小；</li>
<li><code>jstat -gcpermcapacity vmid</code>：显示永久代大小，从 jdk1.8 开始,该选项不存在了，因为永久代被移除了；</li>
<li><code>jstat -gcutil vmid</code>：显示垃圾收集信息；</li>
</ul>
<p>另外，加上 <code>-t</code>参数可以在输出信息上加一个 Timestamp 列，显示程序的运行时间。</p>
<h4 id="jinfo-实时地查看和调整虚拟机各项参数"><a href="#jinfo-实时地查看和调整虚拟机各项参数" class="headerlink" title="jinfo: 实时地查看和调整虚拟机各项参数"></a><strong>jinfo: 实时地查看和调整虚拟机各项参数</strong></h4><p><code>jinfo vmid</code> :输出当前 jvm 进程的全部参数和系统属性 (第一部分是系统的属性，第二部分是 JVM 的参数)。</p>
<p><code>jinfo -flag name vmid</code> :输出对应名称的参数的具体值。比如输出 MaxHeapSize、查看当前 jvm 进程是否开启打印 GC 日志 ( <code>-XX:PrintGCDetails</code> :详细 GC 日志模式，这两个都是默认关闭的)。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span> MaxHeapSize <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:MaxHeapSize=<span class="hljs-number">2124414976</span><br>C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span> PrintGC <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:<span class="hljs-literal">-PrintGC</span><br></code></pre></td></tr></table></figure>

<p>使用 jinfo 可以在不重启虚拟机的情况下，可以动态的修改 jvm 的参数。尤其在线上的环境特别有用,请看下面的例子：</p>
<p><code>jinfo -flag [+|-]name vmid</code> 开启或者关闭对应名称的参数。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span>  PrintGC <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:<span class="hljs-literal">-PrintGC</span><br><br>C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span>  +PrintGC <span class="hljs-number">17340</span><br><br>C:\Users\SnailClimb&gt;jinfo  <span class="hljs-literal">-flag</span>  PrintGC <span class="hljs-number">17340</span><br><span class="hljs-literal">-XX</span>:+PrintGC<br></code></pre></td></tr></table></figure>





<h4 id="jmap-生成堆转储快照"><a href="#jmap-生成堆转储快照" class="headerlink" title="jmap:生成堆转储快照"></a><strong>jmap:生成堆转储快照</strong></h4><p><code>jmap</code>（Memory Map for Java）命令用于生成堆转储快照。 如果不使用 <code>jmap</code> 命令，要想获取 Java 堆转储，可以使用 <code>“-XX:+HeapDumpOnOutOfMemoryError”</code> 参数<strong>，可以让虚拟机在 OOM 异常出现之后自动生成 dump 文件</strong>，Linux 命令下可以通过 <code>kill -3</code> 发送进程退出信号也能拿到 dump 文件。</p>
<p><code>jmap</code> 的作用并不仅仅是为了获取 dump 文件，它还可以查询 finalizer 执行队列、Java 堆和永久代的详细信息，如空间使用率、当前使用的是哪种收集器等。和<code>jinfo</code>一样，<code>jmap</code>有不少功能在 Windows 平台下也是受限制的。</p>
<p>示例：<strong>将指定应用程序的堆快照输出到桌面</strong>。后面，可以通过 jhat、Visual VM 等工具分析该堆文件。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jmap <span class="hljs-literal">-dump</span>:format=b,file=C:\Users\SnailClimb\Desktop\heap.hprof <span class="hljs-number">17340</span><br>Dumping heap to C:\Users\SnailClimb\Desktop\heap.hprof ...<br>Heap dump file created<br></code></pre></td></tr></table></figure>



<h4 id="jhat-分析-heapdump-文件"><a href="#jhat-分析-heapdump-文件" class="headerlink" title="jhat: 分析 heapdump 文件"></a><strong>jhat: 分析 heapdump 文件</strong></h4><p><strong><code>jhat</code></strong> 用于分析 heapdump 文件，它会建立一个 HTTP&#x2F;HTML 服务器，让用户可以在浏览器上查看分析结果。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell">C:\Users\SnailClimb&gt;jhat C:\Users\SnailClimb\Desktop\heap.hprof<br>Reading from C:\Users\SnailClimb\Desktop\heap.hprof...<br>Dump file created Sat May <span class="hljs-number">04</span> <span class="hljs-number">12</span>:<span class="hljs-number">30</span>:<span class="hljs-number">31</span> CST <span class="hljs-number">2019</span><br>Snapshot read, resolving...<br>Resolving <span class="hljs-number">131419</span> objects...<br>Chasing references, expect <span class="hljs-number">26</span> dots..........................<br>Eliminating duplicate references..........................<br>Snapshot resolved.<br>Started HTTP server on port <span class="hljs-number">7000</span><br>Server is ready.<br></code></pre></td></tr></table></figure>

<p>访问 <a target="_blank" rel="noopener" href="http://localhost:7000/">http://localhost:7000</a></p>
<h4 id="jstack-生成虚拟机当前时刻的线程快照"><a href="#jstack-生成虚拟机当前时刻的线程快照" class="headerlink" title="jstack :生成虚拟机当前时刻的线程快照"></a><strong>jstack :生成虚拟机当前时刻的线程快照</strong></h4><p><code>jstack</code>（Stack Trace for Java）命令用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合</p>
<p>生成线程快照的目的主要是定位线程长时间出现停顿的原因，<strong>如线程间死锁、死循环、请求外部资源导致的长时间等待等都是导致线程长时间停顿的原因。</strong>线程出现停顿的时候通过<code>jstack</code>来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做些什么事情，或者在等待些什么资源。</p>
<h3 id="JDK-可视化分析工具"><a href="#JDK-可视化分析工具" class="headerlink" title="JDK 可视化分析工具"></a><strong>JDK 可视化分析工具</strong></h3><h4 id="JConsole-Java-监视与管理控制台"><a href="#JConsole-Java-监视与管理控制台" class="headerlink" title="JConsole:Java 监视与管理控制台"></a><strong>JConsole:Java 监视与管理控制台</strong></h4><p>JConsole 是基于 JMX 的可视化监视、管理工具。可以很方便的监视本地及远程服务器的 java 进程的内存使用情况。你可以在控制台输入<code>jconsole</code>命令启动或者在 JDK 目录下的 bin 目录找到<code>jconsole.exe</code>然后双击启动。</p>
<p><strong>连接 Jconsole</strong></p>
<p>如果需要使用 JConsole 连接远程进程，可以在远程 Java 程序启动时加上下面这些参数:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">-Djava.rmi.server.hostname</span>=<span class="hljs-string">外网访问 ip 地址</span><br><span class="hljs-attr">-Dcom.sun.management.jmxremote.port</span>=<span class="hljs-string">60001   //监控的端口号</span><br><span class="hljs-attr">-Dcom.sun.management.jmxremote.authenticate</span>=<span class="hljs-string">false   //关闭认证</span><br><span class="hljs-attr">-Dcom.sun.management.jmxremote.ssl</span>=<span class="hljs-string">false</span><br></code></pre></td></tr></table></figure>

<p>在使用 JConsole 连接时，远程进程地址如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">外网访问 ip 地址:60001<br></code></pre></td></tr></table></figure>

<p><strong>查看 Java 程序概况</strong></p>
<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418003009546.png" srcset="/img/loading.gif" lazyload alt="image-20240418003009546" style="zoom:50%;" />



<h4 id="Visual-VM-多合一故障处理工具"><a href="#Visual-VM-多合一故障处理工具" class="headerlink" title="Visual VM:多合一故障处理工具"></a><strong>Visual VM:多合一故障处理工具</strong></h4><p>VisualVM 提供在 Java 虚拟机 (Java Virtual Machine, JVM) 上运行的 Java 应用程序的详细信息。在 VisualVM 的图形用户界面中，您可以方便、快捷地查看多个 Java 应用程序的相关信息。Visual VM 官网：<a target="_blank" rel="noopener" href="https://visualvm.github.io/">https://visualvm.github.io/open in new window</a> 。Visual VM 中文文档:<a target="_blank" rel="noopener" href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.htmlopen in new window</a>。</p>
<p>下面这段话摘自《深入理解 Java 虚拟机》。</p>
<blockquote>
<p>VisualVM（All-in-One Java Troubleshooting Tool）是到目前为止随 JDK 发布的功能最强大的运行监视和故障处理程序，官方在 VisualVM 的软件说明中写上了“All-in-One”的描述字样，预示着他除了运行监视、故障处理外，还提供了很多其他方面的功能，如性能分析（Profiling）。VisualVM 的性能分析功能甚至比起 JProfiler、YourKit 等专业且收费的 Profiling 工具都不会逊色多少，而且 VisualVM 还有一个很大的优点：不需要被监视的程序基于特殊 Agent 运行，因此他对应用程序的实际性能的影响很小，使得他可以直接应用在生产环境中。这个优点是 JProfiler、YourKit 等工具无法与之媲美的。</p>
</blockquote>
<p>VisualVM 基于 NetBeans 平台开发，因此他一开始就具备了插件扩展功能的特性，通过插件扩展支持，VisualVM 可以做到：</p>
<ul>
<li><strong>显示虚拟机进程以及进程的配置、环境信息（jps、jinfo）。</strong></li>
<li><strong>监视应用程序的 CPU、GC、堆、方法区以及线程的信息（jstat、jstack）。</strong></li>
<li><strong>dump 以及分析堆转储快照（jmap、jhat）。</strong></li>
<li><strong>方法级的程序运行性能分析，找到被调用最多、运行时间最长的方法。</strong></li>
<li><strong>离线程序快照：收集程序的运行时配置、线程 dump、内存 dump 等信息建立一个快照，可以将快照发送开发者处进行 Bug 反馈。</strong></li>
<li><strong>其他 plugins 的无限的可能性……</strong></li>
</ul>
<p>这里就不具体介绍 VisualVM 的使用，如果想了解的话可以看:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://visualvm.github.io/documentation.html">https://visualvm.github.io/documentation.htmlopen in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-visualvm/index.html</a></li>
</ul>
<h3 id="如何排查线程死锁？"><a href="#如何排查线程死锁？" class="headerlink" title="如何排查线程死锁？"></a><strong>如何排查线程死锁？</strong></h3><p>首先使用jps查找程序的线程</p>
<p>然后使用<strong>jstack 线程id</strong>，就可以找到死锁线程</p>
<p>如下图，t2正在等待锁对象的地址为0x000000076b4alaf8，而t1正在锁住该对象，所以发生了思死锁</p>
<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418160202135.png" srcset="/img/loading.gif" lazyload alt="image-20240418160202135" style="zoom: 67%;" />





<h3 id="如何解决线上CPU飙高"><a href="#如何解决线上CPU飙高" class="headerlink" title="如何解决线上CPU飙高"></a><strong>如何解决线上CPU飙高</strong></h3><p>通过top命令找到CPU占用最厉害的CPU</p>
<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418180232127.png" srcset="/img/loading.gif" lazyload alt="image-20240418180232127" style="zoom:50%;" />

<p>转换16进制线程pid：printf ‘0x%x\n’ 进程ID</p>
<p>jstack 进程ID ｜grep 16进制线程pid -A20</p>
<img src="https://palepics.oss-cn-guangzhou.aliyuncs.com/img/image-20240418180559019.png" srcset="/img/loading.gif" lazyload alt="image-20240418180559019" style="zoom:50%;" />

<p>然后就可以找到哪句代码导致CPU飙高</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/Java/JVM/" class="category-chain-item">JVM</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>JVM调优</div>
      <div>http://example.com/2024/02/23/Java/JVM/JVM调优/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>PALE13</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年2月23日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/23/Java/JVM/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM垃圾回收">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">JVM垃圾回收</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/10/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9F%BA%E7%A1%80/" title="设计模式基础">
                        <span class="hidden-mobile">设计模式基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.5.1/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"fSj01qIZ1mNzIMoPkGGM4LIB-gzGzoHsz","appKey":"OVGCjDnyLgmimKVrlTnxrRC9","path":"window.location.pathname","placeholder":"说点什么","avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
